/**
* @file       Params.h
*
* @brief      Parameter classes for Zerocoin.
*
* @author     Ian Miers, Christina Garman and Matthew Green
* @date       June 2013
*
* @copyright  Copyright 2013 Ian Miers, Christina Garman and Matthew Green
* @license    This project is released under the MIT license.
**/
#ifndef PARAMS_H_
#define PARAMS_H_

#include "../Zerocoin.h"

namespace libzerocoin {

class IntegerGroupParams {
public:
	/** @brief Integer group class, default constructor
	*
	* Allocates an empty (uninitialized) set of parameters.
	**/
	IntegerGroupParams();

	/**
	 * Generates a random group element
	 * @return a random element in the group.
	 */
	Bignum randomElement() const;
	bool initialized;

private:
	/**
	 * A generator for the group.
	 */
	Bignum _g;

	/**
	 * A second generator for the group.
	 * Note log_g(h) and log_h(g) must
	 * be unknown.
	 */
	Bignum _h;
	bool generatorsAreValid;
public:
	// Generator getters; these throw ZerocoinException if generatorsAreValid is
	// false.
	Bignum g() const {
		if (!generatorsAreValid) {
			throw ZerocoinException("Generators are invalid for this group.");
		}
		return _g;
	}

	Bignum h() const {
		if (!generatorsAreValid) {
			throw ZerocoinException("Generators are invalid for this group.");
		}
		return _h;
	}

	// Generator setters; these throw ZerocoinException if generatorsAreValid is
	// false.
	void g(const Bignum& g) {
		if (!generatorsAreValid) {
			throw ZerocoinException("Generators cannot be set for this group.");
		}
		_g = g;
	}
	void h(const Bignum& h) {
		if (!generatorsAreValid) {
			throw ZerocoinException("Generators cannot be set for this group.");
		}
		_h = h;
	}

	// Mark the generators g and h as invalid; this is done for the coin
	// commitment group.
	void invalidateGenerators() {
		_g = 0;
		_h = 0;
		generatorsAreValid = false;
	}

	/**
	 * The modulus for the group.
	 */
	Bignum modulus;

	/**
	 * The order of the group
	 */
	Bignum groupOrder;

	// GNOSIS: I can't think of a good reason to serialize ZC params
	IMPLEMENT_SERIALIZE
	(
	    READWRITE(initialized);
	    READWRITE(_g);
	    READWRITE(_h);
	    READWRITE(modulus);
	    READWRITE(groupOrder);
	)
};

class AccumulatorAndProofParams {
public:
	/**
	 * Nothing much happens in this constructor. :-)
	 */
	AccumulatorAndProofParams();

	bool initialized;

	/**
	 * The moduli N_i used for the accumulator. These are RSA UFOs.
	 * Composite numbers generated by hashing whose complete factorizations
	 * should be unknown.
	 */
	std::vector<const Bignum> accumulatorModuli;

	/**
	 * The initial values for the accumulators
	 * Random quadratic residues mod N_i that are not 1
	 */
	std::vector<const Bignum> accumulatorBases;

	/**
	 * Lower bound on the value for committed coin.
	 * Required by the accumulator proof.
	 */
	Bignum minCoinValue;

	/**
	 * Upper bound on the value for a comitted coin.
	 * Required by the accumulator proof.
	 */
	Bignum maxCoinValue;

	/**
	 * The second of two groups used to form a commitment to
	 * a coin (which it self is a commitment to a serial number).
	 * This one differs from serialNumberSokCommitment due to
	 * restrictions from Camenisch and Lysyanskaya's paper.
	 */
	IntegerGroupParams accumulatorPoKCommitmentGroup;

	/**
	 * Hidden order quadratic residue groups mod N_i.
	 * Used in the accumulator proofs.
	 */
	std::vector<const IntegerGroupParams> accumulatorQRNCommitmentGroups;

	/**
	 * Security parameter.
	 * Bit length of the challenges used in the accumulator proof.
	 */
	uint32_t k_prime;

	/**
	 * Security parameter.
	 * The statistical zero-knowledgeness of the accumulator proof.
	 */
	uint32_t k_dprime;

	// GNOSIS: I can't think of a good reason to serialize ZC params
	IMPLEMENT_SERIALIZE
	(
	    READWRITE(initialized);
	    READWRITE(accumulatorModuli);
	    READWRITE(accumulatorBases);
	    READWRITE(accumulatorPoKCommitmentGroup);
	    READWRITE(accumulatorQRNCommitmentGroups);
	    READWRITE(minCoinValue);
	    READWRITE(maxCoinValue);
	    READWRITE(k_prime);
	    READWRITE(k_dprime);
	)
};

class Params {
public:
	/** @brief Construct a set of Zerocoin parameters from a modulus "N".
	* @param N                A trusted RSA modulus
	* @param securityLevel    A security level expressed in symmetric bits (default 80)
	*
	* Allocates and derives a set of Zerocoin parameters, including
	* a set of RSA UFOs. This routine calculates all of the remaining
	* parameters (group descriptions etc.) from N using a verifiable,
	* deterministic procedure.
	*
	* Note: this constructor makes the fundamental assumption that "N"
	* encodes a valid RSA-style modulus of the form "e1 * e2" where
	* "e1" and "e2" are safe primes. The factors "e1", "e2" MUST NOT
	* be known to any party, or the security of Zerocoin is
	* compromised. The integer "N" must be a MINIMUM of 1024
	* in length. 3072 bits is strongly recommended.
	**/
	Params(uint32_t securityLevel = ZEROCOIN_DEFAULT_SECURITYLEVEL);

	bool initialized;

	AccumulatorAndProofParams accumulatorParams;

	/**
	 * The Quadratic Residue group from which we form
	 * a coin as a commitment  to a serial number.
	 */
	IntegerGroupParams coinCommitmentGroup;

	/**
	 * One of two groups used to form a commitment to
	 * a coin (which it self is a commitment to a serial number).
	 * This is the one used in the serial number poof.
	 * It's order must be equal to the modulus of coinCommitmentGroup.
	 */
	IntegerGroupParams serialNumberSoKCommitmentGroup;

	/**
	 * The number of iterations to use in the serial
	 * number proof.
	 */
	uint32_t zkp_iterations;

	/**
	 * The amount of the hash function we use for
	 * proofs.
	 */
	uint32_t zkp_hash_len;

	// GNOSIS: I can't think of a good reason to serialize ZC params
	IMPLEMENT_SERIALIZE
	(
	    READWRITE(initialized);
	    READWRITE(accumulatorParams);
	    READWRITE(coinCommitmentGroup);
	    READWRITE(serialNumberSoKCommitmentGroup);
	    READWRITE(zkp_iterations);
	    READWRITE(zkp_hash_len);
	)
};

} /* namespace libzerocoin */

#endif /* PARAMS_H_ */
